<!doctype html>
<html>
  <head>
    <!-- 
      This site is built with Gumdrop: https://github.com/darthapo/gumdrop
        (The source files are under _source)
    -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>blam.js by darthapo</title>

    <link rel="stylesheet" href="stylesheets/highlight/github.css">
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="/html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>

        <h1>blam.js</h1>

        <p>Templates are just code.</p>

        <p><a href="test/index.html">Run the unit tests...</a></p>


        <p class="view"><a href="https://github.com/darthapo/blam.js">View the Project on GitHub <small>darthapo/blam.js</small></a></p>
        <ul>
          <li><a href="https://github.com/darthapo/blam.js/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/darthapo/blam.js/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/darthapo/blam.js">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
<!-- Content -->
      <h1 id="blamjs">blam.js</h1>

<p><strong>Simple, Tiny, Fast</strong> (enough)</p>

<p>Example usage (in CoffeeScript):</p>

<pre class="coffeescript"><code>blam(-&gt;
  html(
    head(
      title( "Hello" )
      script( src:"/my-script.js" )
    )
    body(
      article( id:"main",
        section.content(
          p("Loading...")
        )
        aside.sidebar( "Nav here" )
      )
    )
  )
)
</code></pre>

<p>You can use it in JavaScript too (but it's much prettier in CoffeeScript):</p>

<pre class="javascript"><code>blam(function(){
  return html(
    head(
      title( "Hello" ), 
      script({ src: "/my-script.js" }),
    ), 
    body(
      article({ id: "main" }, 
        section.content(
          p("Loading...")
        ), 
        aside.sidebar( "Nav here")
      )
    )
  )
});
</code></pre>
<p>If you like, you can compile string templates as well (you'll need to use the javascript syntax):</p>

<pre class="html"><code>&lt;script type="text/blam" id="my_template"&gt;
article.container(
  section.main(
    p("Hello!")
  ),
  aside.sidebar(
    ul(
      li("Navigation, mayhaps?")
    )
  )
)
&lt;/script&gt;
&lt;script&gt;
var template_string= document.getElementById('my_template');
// Render it...
var html= blam( template_string );

// Or if you're gonna reuse the template, you should probably compile it:
var template= blam.compile( template_string );

// then however many times you want
var html= template();
&lt;/script&gt;
</code></pre>

<h2 id="notes">Notes</h2>

<p>Clocks in at ~1K minified and gzipped.</p>

<p>MIT Licensed.</p>

<p>Unit tests can be found at: <a href="http://darthapo.github.com/blam.js/test">darthapo.github.com/blam.js/test</a></p>

<p><strong><em>Please</em> let me know if any of the tests break in your browser!</strong></p>

<p>If the first argument to a tag block is an object literal then its key/value pairs are used as tag attributes.</p>

<pre class="coffeescript"><code>blam -&gt;
  div( id:"posts", 'data-role':"post",
    p("content here...")
  )
# =&gt; '&lt;div id="posts" data-role="post"&gt;&lt;p&gt;content here...&lt;/p&gt;&lt;/div&gt;'
</code></pre>

<p>Blam will pass initial arguments on to the markup block:</p>

<pre class="coffeescript"><code>blam name:'Matt', (user)-&gt;
  div( id:'user-block',
    p("Hello ", user.name)
  )
</code></pre>

<p>Markup blocks can be &quot;compiled&quot; into an executable function (good for often repeated bits of code):</p>

<pre class="coffeescript"><code>template= blam.compile (user)-&gt;
  div( id:'user-block',
    p("Hello ", user.name)
  )

html+= template(user) for user in all_users
</code></pre>

<p>For array elements you can use the <code>each</code> tag:</p>

<pre class="coffeescript"><code>template= blam.compile (users)-&gt;
  div( id:'user-block',
    each(users, (user)-&gt;
      p("Hello ", user.name)
    )
  )

html+= template(all_users)
</code></pre>

<p>You can create partials/custom tags:</p>

<pre class="coffeescript"><code>blam.define 'layout', -&gt;
  article.container(
    header( h1( "My App" ) )
    section.body( __(arguments) )
    footer( p("&amp;copy; me!") )
  )
</code></pre>

<p>You can then use it like a tag:</p>

<pre class="coffeescript"><code>blam @posts, (posts)-&gt;
  layout(
    div.posts(
      each(posts, (post)-&gt;
        div.entry( post.body )
      )
    )
  )
</code></pre>

<p>You can turn off the fancy auto css class support:</p>

<pre class="coffeescript"><code>blam.fancy(no)

# You have to use the attributes hash to add classnames now:
blam -&gt;
  div( class:'my-class', "Content")
</code></pre>

<h2 id="scopes">Scopes</h2>

<p>You can add a single object to a markup block's scope when pre-compiling templates:</p>

<pre class="coffeescript"><code>data=
  name: 'He'
  age: 'Old Enough'

template= blam.scope(data).compile -&gt;
  div( name, " is ", age )

html= template()
#=&gt; "&lt;div&gt;He is Old Enough&lt;/div&gt;"
</code></pre>

<h2 id="backbone-mini-example">Backbone Mini Example</h2>

<pre class="coffeescript"><code>class TweetView extends Backbone.View
  @template: blam.compile (tweet)-&gt;
    div.tweet(
      img.avatar( 
        src: tweet.profile_image_url
        alt: tweet.from_user_name
      )
      div.status(
        tweet.status
      )
      div.footer(
        "@"
        tweet.from_user
        " said on "
        tweet.created_at
      )
    )

  render: -&gt;
    @$el.html TweetView.template( @model.toJSON() )
</code></pre>

<h2 id="nodejs">Node.js</h2>

<p>Blam is available as an npm package as well. To install:</p>

<pre class="bash"><code>npm install blam
</code></pre>

<p>Or, use the <code>-g</code> option to install it globally:</p>

<pre class="bash"><code>npm install blam -g
</code></pre>

<p>Then <code>require</code> it as per usual in node:</p>

<pre class="javascript"><code>var blam= require('blam').blam;

blam.compile(function(){ return div("etc...") })
</code></pre>

<h2 id="todo">Todo</h2>

<ul>
  <li>
    <p>Need to cleanup this ReadMe and create some proper docs.</p>
  </li>
  <li>
    <p>Would like to support all the modern browsers and possibly as far back as IE8?</p>
  </li>
  <li>
    <p>Need to test AMD support.</p>
  </li>
  <li>
    <p>Extract and expose tag building helpers.</p>
  </li>
</ul>

<h2 id="arent-eval-and-with-evil">Aren't <code>eval</code> and <code>with</code> Evil?</h2>

<p><strong>No!</strong> They're just <em>misunderstood</em>. Blam.js is a good example of why they are useful as language features. They allow excellent DSL generation.</p>

<p>That having been said, it <em>is</em> a good rule of thumb that if you don't know when is best to use them; don't.</p>

<!-- /Content -->
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/darthapo">darthapo</a></p>
        <p><small>Hosted on GitHub Pages <br> Theme by <a href="https://github.com/orderedlist">orderedlist</a> <br> Site built with <a href="https://github.com/darthapo/gumdrop">Gumdrop v0.7.5</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="blam.min.js"></script>
  </body>
</html>